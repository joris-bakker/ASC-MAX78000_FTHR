/*******************************************************************************
Diese Programm dient der Überprüfung des Quantisierten Modells. Die c header dateien im testordner sind Header des Testdatensatzes. Der Komplette Datensatz befindet sich im Ordner Headers
*******************************************************************************/

// tut2017_final_jupyter
// This file was @generated by ai8xize.py --test-dir CNN_example --prefix tut2017_final_jupyter --checkpoint-file custom_tut2017/1dcnn_final_checkpoint_q8.pth.tar --config-file custom_tut2017/classifier_final.yaml --device MAX78000 --timer 0 --display-checkpoint --verbose --softmax --overwrite

#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include <stdio.h>
#include "mxc.h"
#include "cnn.h"
#include "sampledata.h"
#include "sampleoutput.h"


#include "test/29.h"
#include "test/30.h"
#include "test/31.h"
#include "test/32.h"


volatile uint32_t cnn_time; // Stopwatch

//input laden
static uint32_t input_0[311] = {0};
static uint32_t input_4[311] = {0};
static uint32_t input_8[311] = {0};
static uint32_t input_12[311] = {0};
static uint32_t input_16[311] = {0};
static uint32_t input_20[311] = {0};
static uint32_t input_24[311] = {0};
static uint32_t input_28[311] = {0};
static uint32_t input_32[311] = {0};
static uint32_t input_36[311] = {0};

int8_t input_array [40][311];
uint32_t mfcc_q32[10][311];

typedef union {
    int32_t value;
    int8_t  bytes[4];
} Int32Union;



void fail(void)
{
  printf("\n*** FAIL ***\n\n");
  while (1);
}


void load_input(void)
{



// Dataloading für CNN Beschleuniger, jeweils 4 8-Bit-Werte werden zu einem 32Bit wert zusammengefasst. Anschließend werden die Daten den Gruppenspeicheradressen zugeordnet
// MFCC ist 40x311  311 Reihen
    // Für jede der 311 Reihen:
    for (int z = 0; z < 311; z++) {
       
        for (int i = 0; i < 10; i++) {
            Int32Union u;  // Union zur Zusammenführung von 4 int8_t-Werten in einen 32-Bit-Wert

            
            u.bytes[0] = input_array[i * 4 + 0][z];
            u.bytes[1] = input_array[i * 4 + 1][z];
            u.bytes[2] = input_array[i * 4 + 2][z];
            u.bytes[3] = input_array[i * 4 + 3][z];

            // Speicherung des zusammengefügten 32-Bit-Wertes in mfcc_q32
            mfcc_q32[i][z] = u.value;
        }
    }

    // Array von Zeigern auf die statischen Input-Arrays
    uint32_t *dest_arrays[10] = {
        input_0,   // Kanal 0
        input_4,   // Kanal 1
        input_8,   // Kanal 2
        input_12,  // Kanal 3
        input_16,  // Kanal 4
        input_20,  // Kanal 5
        input_24,  // Kanal 6
        input_28,  // Kanal 7
        input_32,  // Kanal 8
        input_36   // Kanal 9
    };

    
    for (int channel = 0; channel < 10; channel++) {
        memcpy(dest_arrays[channel], mfcc_q32[channel], 311 * sizeof(uint32_t));
    }

    // Übertrage die Daten in den entsprechenden Speicherbereichen des CNN-Beschleunigers
    memcpy32((uint32_t *) 0x50400000, input_0, 311);
    memcpy32((uint32_t *) 0x50408000, input_4, 311);
    memcpy32((uint32_t *) 0x50410000, input_8, 311);
    memcpy32((uint32_t *) 0x50418000, input_12, 311);
    memcpy32((uint32_t *) 0x50800000, input_16, 311);
    memcpy32((uint32_t *) 0x50808000, input_20, 311);
    memcpy32((uint32_t *) 0x50810000, input_24, 311);
    memcpy32((uint32_t *) 0x50818000, input_28, 311);
    memcpy32((uint32_t *) 0x50c00000, input_32, 311);
    memcpy32((uint32_t *) 0x50c08000, input_36, 311);
}




// Classification layer:
static int32_t ml_data[CNN_NUM_OUTPUTS];
static q15_t ml_softmax[CNN_NUM_OUTPUTS];

void softmax_layer(void)
{
  cnn_unload((uint32_t *) ml_data);
  softmax_q17p14_q15((const q31_t *) ml_data, CNN_NUM_OUTPUTS, ml_softmax);
}

int main(void)
{
//  int i;
//  int digs, tens;

  MXC_ICC_Enable(MXC_ICC0); // Enable cache

  // Switch to 100 MHz clock
  MXC_SYS_Clock_Select(MXC_SYS_CLOCK_IPO);
  SystemCoreClockUpdate();
//
//  printf("Waiting...\n");

  // DO NOT DELETE THIS LINE:
  MXC_Delay(SEC(2)); // Let debugger interrupt if needed

  // Enable peripheral, enable CNN interrupt, turn on CNN clock
  // CNN clock: APB (50 MHz) div 1
  cnn_enable(MXC_S_GCR_PCLKDIV_CNNCLKSEL_PCLK, MXC_S_GCR_PCLKDIV_CNNCLKDIV_DIV1);

//  printf("\n*** CNN Inference Test tut2017_final_jupyter ***\n");

  cnn_init(); // Bring state machine into consistent state
  cnn_load_weights(); // Load kernels
  cnn_load_bias();
  cnn_configure(); // Configure state machine





  ///////////////////////////////////////////////////////////////////////////////////////



  int8_t (*arrays[])[311] = { array29,
		  	  	  	  	  	  array30,
							  array31,
							  array32,};


  for (int i= 0; i<4 ; i++ )
  {
	  memcpy(input_array, arrays[i], sizeof(input_array));
  load_input(); // Load data input
  cnn_start(); // Start CNN processing

  while (cnn_time == 0)
    MXC_LP_EnterSleepMode(); // Wait for CNN


softmax_layer();


  float max = ml_data[0];
  int size = sizeof(ml_data) / sizeof(ml_data[0]); // Anzahl der Elemente im Array
  int index = 0; // Speichert die Position des größten Wertes

      for (int i = 1; i < size; i++) {
          if (ml_data[i] > max) {
              max = ml_data[i];
              index = i;
          }
      }
      printf("klasse %d \n", index);


  }


  return 0;
}

/*
  SUMMARY OF OPS
  Hardware: 40,273,024 ops (40,088,064 macc; 146,560 comp; 38,400 add; 0 mul; 0 bitwise)
    Layer 0 (L1): 3,949,248 ops (3,929,600 macc; 19,648 comp; 0 add; 0 mul; 0 bitwise)
    Layer 1 (L2): 7,534,720 ops (7,495,680 macc; 39,040 comp; 0 add; 0 mul; 0 bitwise)
    Layer 2 (L3): 24,653,312 ops (24,576,000 macc; 77,312 comp; 0 add; 0 mul; 0 bitwise)
    Layer 3 (L4): 3,729,600 ops (3,686,400 macc; 4,800 comp; 38,400 add; 0 mul; 0 bitwise)
    Layer 4 (L5): 398,976 ops (393,216 macc; 5,760 comp; 0 add; 0 mul; 0 bitwise)
    Layer 5 (L6): 7,168 ops (7,168 macc; 0 comp; 0 add; 0 mul; 0 bitwise)

  RESOURCE USAGE
  Weight memory: 269,824 bytes out of 442,368 bytes total (61.0%)
  Bias memory:   551 bytes out of 2,048 bytes total (26.9%)
*/

